# 编程思想07复用类

**复用代码是 Java 众多引人注目的功能之一。**

Java 可以通过创建类来复用代码，要在使用类的时候不破坏现有代码，有两种方式：

- 组合：在新的类中使用现有类的对象。即新的类是由现有类的对象所组成。
- 继承：按照现有类的类型来创建新类，无需改变现有类的形式，并为其添加新代码。



## 组合语法

* 使用组合技术只需要将对象引用置于新类中。

  * 对于非基本数据类型的对象，必须将其引用置于新类中
  * 基本数据类型可以直接定义

* 每个非基本类型的对象都有一个 `toString()` 方法，而且当编译器需要一个 String 而你传入一个对象时，`toString()` 会被调用。

* 类中的对象引用会被默认初始化为 null，如果你对其调用任何方法都会抛出异常，但是可以在不抛出异常的情况下，仍然可以打印一个 null 引用

* 类中对象引用的初始化位置：

  - 在定义对象的地方
  - 在类的构造器中
  - 惰性初始化，即在要使用该对象的地方进行初始化
  - 实例初始化




## 继承语法

* 继承是 OOP 语言和 Java 语言不可缺少的部分，当创建一个类时，总是在继承，即使没有显式继承某个类，也会隐式地从 Object 类中继承。
* 继承由关键词 `extends` 指定，其形式如`class Detergent extends Cleanser{}`，基类的所有方法和成员都会自动导入到导出类中。**【父类中被public，protected、default（同包情况下）修饰的，才可以被导出类访问】**
* 可以为每个类都创建一个 main 方法，这样可以使得每个类的单元测试变得简便。即使某个类只有包访问权限，其`public main`也可以通过 `java className`的方式访问到
* 为了继承，一般是将所有的数据成员都指定为 private，将所有的方法指定为 public。
* 我们对继承来的方法进行重写，重写之后可以通过 `super` 关键词访问基类版本的方法，如`super.func()`;
* Java 会**自动在导出类的构造器中插入对基类构造器的调用【调用的是默认的基类构造器】，其总是在导出类构造器执行之前，即使是在定义处初始化的语句也会在基类构造器执行之后执行。**
* 即使没有为导出类创建构造器，编译器也会在默认构造器中调用基类的构造器
* 如果没有默认的基类构造器，或者想要调用一个带有参数的基类构造器，就必须使用 super 关键词显式调用基类构造器，**调用基类构造器必须是在你导出类构造器的第一条语句**。
  * super关键字指向的是自己超类对象的一个引用（离自己最近的一个父类）
    * super(参数)：调用基类中的某个构造函数，放在构造函数的第一条语句
    * super.变量名，super.方法名(参数)：引用父类中的成员或调用父类中的方法
    * this(参数)和super(参数)不能同时出现在同一个构造函数里面，因为this必然会调用其他构造函数，其他构造函数必然也会有super语句的存在【即不允许构造两个父类对象】




## 代理

* 代理是指，我们将一个成员对象置于要构造的类中（像组合），但与此同时我们在新类中暴露该成员对象的所有或部分方法（像继承）。

IDEA自动创建代理的过程：

- 先在代理类中声明要代理的成员。
- `Alt + Insert`快捷键，选中 `Delegation`
- 选中要代理的函数即可。



## 结合使用组合继承

* 可以结合组合和继承来创建复杂的类
* 编译器会强制你去初始化基类，并且要求在构造器最开始出就要这么做，但是它不会要求你对成员对象进行初始化，因此需要自己注意。
* Java 中没有 C++ 中的析构函数，就像之前所说的一样，如果我们的类的确需要做一些类似的工作（如关闭文件），我们需要自己实现一个方法来实现，而当涉及到继承时，我们要确保以正确的顺序调用该函数，推荐和C++中析构函数的执行顺序一样编写该函数，即先清理导出类本身，再调用基类的清理函数。【必须注意对基类清理方法和成员对象清理方法的调用顺序，以防某个子对象依赖于另一个子对象情形的发生，清理顺序一般与生成顺序相反】
* 清理函数需要放在 finally 子句中，以防异常的出现，导致清理函数未被执行，可参考练习12
* 如果 Java 的基类拥有某个已经被多次重载的方法名称时，在导出类中重新定义该方法的名称，不会屏蔽其在基类中的任何版本。这意味着，在导出类中，重载和重新定义（重写）容易混淆在一起，如果不看基类的定义是很难分辨某个方法是否正确的被重新定义了。我们可以使用`@Override`注解来标识某个方法我们希望其是重写而不是重载，如果一不小心重载了，则会出现编译错误来提醒我们。



## 在组合与继承之间选择

* 组合和继承都允许在新的类中放置子对象，组合是显式地这样做，而继承则是隐式地这样做。

* 组合技术通常用于想在新类中使用现有类的功能而非它的接口这种情况。有时，允许类的用户直接访问新类中组合成分是有意义的。

  * 一般组合的现有类为private对象，使新类的用户看到的只是为新类所定义的接口，而非嵌入对象的接口，隐藏了具体的实现，这种做法是安全的。
  * 有时，允许类的用户直接访问新类中的组合对象是极具意义的，即声明为public，这可以使端口更加易于理解。

* 在继承时，使用某个现有类，开发一个它的特殊版本。通常，这意味着你在使用一个通用类，并为了某种特殊需要而将其特殊化。

  * 继承可以用（is a）”是一个“的关系来表达，组合则用（has a）有一个关系表达

  

## 向上转型

* **向上转型即将导出类引用转换为基类引用的动作**

  * ```java
    Son son = new Son();
    Father father = son; //自动进行
    ```

* “为新的类提供方法”不是继承中最重要的部分，其重要的方面是用来表现新类和基类之间的关系。简单的说，我们可以认为“导出类是基类的一种类型”，即可以把导出类当成基类来使用

* 由于导出类转换为基类在继承图上是向上移动的，因为我们将其成为“向上转型”

* 向上转型是从一个较为专用的类向较为通用的类转变

* 虽然在教授OOP的过程中多次强调继承，但是我们应该慎用继承。**判断是否要使用的继承的一个简单方法就是，判断我们是否要进行向上转型，如果要进行向上转型，则用继承，反之，则用组合。**

  

## final 关键字

**final 关键词的含义通常指只能被赋值一次且“无法改变的”，使用这个关键词通常是因为设计和效率的原因。final 可以用在数据、方法和类上。**



### final数据

* 数据的恒定不变分为两种情况：**编译时常量**和在**运行时初始化并并无法的改变的值。**
  * 对于编译时常量，编译器可以将该常量值代入任何可能用到它的计算式中，也就是说，可以在编译时执行计算式，【编译期就知道它的值】

- 在 Java 中，**编译时常量必须是基本数据类型，并且用关键词 final 表示，并在该常量定义时对其初始化**，如`final int value = 1`。通常，编译时常量还是一个`static`数据，即`static final int VALUE_ONE = 1`。
- 编译器常量的命名规则是：全用大写字母，单词与单词之间用`_`隔开
- 即使一个变量是`final`,我们也无法确定其是编译时常量【无法在编译期就知道它的值】，因为初始化没有要求是字面量，即初始化可以通过调用函数实现，如`final int value = rand.nextInt(20)`。
- 同时一个`final`数值，如果其是`static`的，那么它可能是在类导入时初始化的，而他不是`static`的话，它是在实例化时初始化的。
  - 一个既是static又是final的域只占据一段不能改变的存储空间。【static final修饰的域也可以被非常量表达式初始化（无法在编译器就知道它的值）】
- 对于基本变量，final 使数值恒定不变，但是对于对象引用，其只是要求对象引用不变，即不指向新的对象，而对象本身是可以被修改的。
- Java 允许“空白 final”，即被声明为 final 但是又没有给定初值的域，虽然可以在定义时不给定初值，**按时编译器会保证，final 域在使用前都必须被初始化**，即**如果没有在定义处给定 final 域的初值的话，就必须在`每个构造器`中对该 final 域进行赋值。**
- Java 允许在参数列表中以声明的方式将参数指明为 final【这一特性主要用来向匿名内部类传递数据】，其含义为，在该函数中无法修改该变量：
  - 参数类型为基本类型：可以读参数，但是不能修改
  - 参数类型为对象类型：无法修改引用
- **对于final修饰的成员变量而已，为了避免使用默认值，java要求实例变量必须在声明时或者构造方法中对它赋值；同时要求类变量必须在声明时初始化【static域可能无需类实例化就被调用】**



### final方法



- 可以将一个方法定义成 final，这样可以防止任何继承类修改它的含义（即**导出类无法覆盖实现【重写】**）
- 在 Java 的早期实现中，对 final 方法的调用会被转为内嵌调用（C++ 中的 inline），但是现在不需要用这样的方式来优化代码了
- 类中的所有 private 方法都被隐式的指定为 final
- **“覆盖”只有在方法是基类的接口的一部分时才会出现，即必须能将一个对象向上转型为它的基本类型并调用相同的方法**，如果一个方法是 private，那么它就不是基类接口的一部分。它仅是一些隐藏于类中的代码，只不过具有相同的名称而已。

```java
static class Father {
    private void f() {
        System.out.println("father");
    }

    public void m() {
        System.out.println("father");
    }
}

static class Son extends Father {
    //        @Override 不是覆盖 private修饰的方法不是基类接口中的一部分 导出类相同签名的方法仅是生成了一个新的方法
    public void f() {
        System.out.println("son");
    }

    //m()方法是父类接口的一部分 才是覆盖
    @Override
    public void m() {
        System.out.println("son");
    }
}

public static void main(String[] args) {
    Son son = new Son();
    Father father = son;
    //father 向上转型后反而调用了父类的方法 故不是覆盖
    father.f();
    //son 向上转型后调用了相同的方法
    father.m();
}
```





### final类

* 当将一个类的整体定义为 final 时，就表明该类无法被继承，同时隐式地将所有方法都定义为 final。【出于某种考虑，对该类的设计永不需要做任何的变动，或者出于安全考虑，不希望它有子类】
* 无论类是否被定义为final，相同的规则都适用于定义为final的域
* final类包括String、以及各种包装类
* 



## 初始化及类的加载

* 每个类的编译代码都存在与他自己独立的文件中。该文件只有在需要使用程序代码的时候才会被加载。

* 一般来说，只有在“类首次使用才加载”，即加载发生于第一次创建类的对象或第一次使用类中的静态域或静态方法。【首次使用之处也是static初始化发生之处】

* 在加载导出类是，Java 编译器会注意到它继承于某个基类，因此他会先去加载该基类。

  * 类加载顺序
    * 静态域【静态代码块、静态成员，静态方法】初始化（注意这里静态方法并不会执行！）先初始化父类静态域再初始化子类静态域，类中初始化顺序为类中按定义的顺序
    * 导出类的static初始化可能会依赖于基类成员能否被正确初始化。所以这种先父类再子类的初始化顺序很重要
  * 创建对象时
    * 实例域初始化(无显式赋值则默认赋初值)，然后执行构造器 （先创建父类对象然后创建子类对象）

  

