# 编程思想chr 9 接口



## 抽象类和抽象方法

* 创建抽象类是希望通过这个通用接口操纵一系列类
* 抽象方法仅有声明没有方法体
  * 包含抽象方法的类叫做抽象类。如果一个类至少包含一个抽象方法，该类必须被限定为abstract
* 为抽象(abstract)类创建对象是不安全的
* 如果从一个抽象类继承，并想创建该新类的对象，则必须为基类中的所有抽象方法提供方法定义，否则导出类也被限制是抽象类
* 抽象类也可以没有抽象方法
  * 这样的类包含任何抽象方法都没有实际意义，且不能产生这个类的任何对象
* 创建抽象类和抽象方法非常有用，因为他们可以使类的抽象性明确起来，并告诉用户和编译器打算怎样来使用他们。



## 接口

* interface关键字使抽象的概念更向前迈进了一步

  * abstract关键字允许人们在类中创建一个或多个没有任何定义的方法（提供接口部分）
  * interface这个关键字产生一个完全抽象的类，它并没有提供任何具体实现
* 一个接口表示：“所有实现了该特定接口的类看起来都像这样”，因此任何使用某特定接口的代码都知道可以调用该接口的哪些方法，而且仅需知道这些。**接口被用来建立类与类之间的协议**。
* 接口里的方法默认都是public【域也默认是public的】，毕竟协议是需要公开暴露的。
* 接口里的域默认都是static的，在多接口实现场景可以区分同名域属于哪个接口。
* 接口里的域默认都是final的，如果域可以修改，那么就没有继承意义，接口要的就是协议化，另外一个角度：因为是static的所以一个接口的域只能有一个实例，所以需要用的话只能在接口先初始化，对于实现类对象没有任何修改的意义。
* 因为枚举enum的出现，所以用接口单纯描述域就显得过时了。
* 抽象类可以含有私有成员变量，接口不含有私有成员变量。接口中的成员变量都是public static final的，一般用作常量。
* 抽象类和接口中的方法都没有方法体。抽象类中的方法(非抽象方法)是可以有方法体的。**JDK1.8之后，接口中的方法也可以有方法体，如果被default或者static之一修饰,可以有方法体,实现类可以不实现此方法(注意,只能是static或者default之一修饰,如果接口中某方法同时被static和default修饰,就会报错)**




## 完全解耦

* **利用接口从具体实现中解耦使得接口可以应用于多种不同的具体实现，代码也就更具可复用性。**



## 多重继承

* 接口不仅仅只是一种更纯粹形式的抽象类，它的目标比这更高，因为接口是根本没有任何具体实现的，也没有任何与接口相关的存储，因此也就无法阻止多个接口的组合。
* 组合多个类的接口的行为被称为**多重继承**
* 在导出类中，不强制要求有一个是抽象的或具体的基类，如果要从一个非接口的类继承，那么只能从一个类去继承，其余的基元素必须是接口。可以继承任意多个接口，并可以向上转型为每个接口，因为每个接口都是一个独立的类型。
* 将一个具体类和多个接口组合到一起时，这个具体类必须放到前面，后面跟着的才是接口。



### 使用接口的核心原因

* 能够向上转型为多个基类型，以及由此带来的灵活性
* 防止创建该类对象，并确保这仅仅是建立一个接口



### 使用抽象类还是接口

* 如果要创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类
* 事实上，恰当的原则应该是**优先选择类而不是接口**，从类开始，如果接口的必需性变得非常明确，那么就进行重构。



## 通过继承来扩展接口

* 通过继承，可以很容易在接口中添加新的方法声明，还可以通过继承在新接口中组合数个接口。这两种情况都可以获得新的接口。

* 一般情况下，只可以将extends用于单一类但是可以引用多个基类接口

  ```java
  interface A extend B,C{
      
  }
  ```

  

## 嵌套接口

* 接口可以嵌套在类或者其他接口中。

- 作用于接口的各种规则，特别是所有的接口元素都必须是public，因此嵌套在另一个接口中的接口自动就是public的，而不能声明为private的。
- 当实现某个接口时，并不需要实现嵌套在其内部的任何接口，此时嵌套接口相当于内部成员变量，未必要被实现，可以单独实现外部接口或者嵌套接口。
- 类中嵌套的接口可以声明为private，且实现一个private接口只是一种方式，它可以强制该接口中的方法定义不要添加任何类型信息（不允许向上转型）
  - 私有接口不能在定义它的类之外被实现（外部不能访问）。



## 接口和工厂

* 接口是实现多继承的途径，遵循某个接口的对象的典型方式就是“工厂方法”设计模式
* 通过工厂对象将生成接口与某个实现的对象彻底分开。我们只需要调用工厂方法，就会自动给我们一个返回的对象。



## 抽象类和接口的区别



### 抽象类

* 含有abstract修饰符的class即为抽象类，abstract类不能创建的实例对象。
* 含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。**抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。**
* abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。
* 如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。 
* 抽象类和普通类最大的区别是，**抽象类不能被实例化，需要继承抽象类才能实例化其子类。**



### 接口

* **接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。**【在 Java 8 之前】
* **从 Java 8 开始，接口也可以拥有默认的方法实现**，这是因为不支持默认方法的接口的维护成本太高了。
* **接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。** 



### 两者的语法区别

​	1.**抽象类可以有构造方法，接口中不能有构造方法。** 
​	2.抽象类中可以有普通成员变量，接口中没有普通成员变量 
​	3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。 

4. 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然 eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。 
5. 抽象类中可以包含静态方法，接口中不能包含静态方法 
6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。 
7. 一个类可以实现多个接口，但只能继承一个抽象类。



### 两者在应用上的区别

* 接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用，

https://www.nowcoder.com/test/question/done?tid=46530287&qid=15179#summary

比较两者语法细节区别的条理是：先从一个类中的构造方法、普通成员变量和方法（包括抽象方法），静态变量和方法，继承性等6个方面逐一去比较回答，接着从第三者继承的角度的回答，特别是最后用了一个典型的例子来展现自己深厚的技术功底。 

