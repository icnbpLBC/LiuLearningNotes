# redis设计与实现 chr02 简单动态字符串

* Redis没有直接使用C字符串，而是直接构建了简单动态字符串SDS，并将其作为redis的默认字符串。

* Redis中，C字符串只会作为字符串字面量表示，用在一些无需对字符串值修改的地方 ，

  **对于需要被修改的字符串，redis会使用SDS表示**。

* 除了用来保存数据库中的字符串值外，SDS还被用作缓存区



## SDS定义

* `动态字符串`(`Simple Dynamic String` 简称 `SDS`)
*  string是以一种纯字符串作为value的形式存在的。也是这几种之中使用最多的数据结构。value可以存储json格式、数值型等。

```java
struct sdshdr {
    uint8_t len; /* used，使用的字节数 */
    uint8_t alloc; /* excluding the header and null terminator，预分配总字节数，不包括结束符\0的长度 */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[]; /*c风格的字符，包括结束符\0*/
};

```

* int len ： 记录buf数组已使用字节的数量，即SDS所保存字符串的长度。保存空字符的1字节不算在内
* int free：记录buf数组未使用字节数量
* char buf[]：字节数组，用于保存字符串



## SDS与C字符串的区别

### 常数复杂度获取字符串长度

* C字符串不记录字符串的长度，需要遍历才能获取，而SDS记录了所以常数时间获取。



### 杜绝缓冲区溢出

* C字符串进行拼接时，如果未分配足够的空间，可能会造成缓冲区溢出。SDS修改时，会先检查空间是否满足要求，不满足会自动扩展空间，才执行修改，完全杜绝了缓冲区溢出的可能。

 

### 减少修改字符串时带来的内存重分配次数

* 增长或缩短C字符串时，总是需要内存重分配操作，而该操作非常耗时，修改n次将有n次该操作。SDS通过未使用空间避免了这种缺陷。



#### 空间预分配

* 用于优化SDS的增长操作，需要对SDS空间扩展时，**不仅会分配修改所必须的空间，还会分配额外的未使用空间**。
* 额外分配未使用空间数量：
  * 修改后,SDS的长度【len】小于1mb，将分配和len大小一样的未使用空间。
  * 修改后,SDS的长度【len】大于等于1mb，将分配1mb的未使用空间。
* 可以减少连续执行字符串增长操作所需的内存重分配次数。



#### 惰性空间释放

* 用于优化SDS的字符串缩短操作

* 需要缩短sds时，**并不立即使用内存重分配来回收多出来的字节，而是使用free属性将这些字节记录下来，等待将来使用。**
* 避免了缩短字符串所需的内存重分配操作，为将来可能的增长操作提供了优化。



### 二进制安全

* C字符串存在限制【字符必须符合某种编码、字符串内部不能含有空字符】，使得C字符串**只能保存文本数据，而不能保存二进制数据。**

* SDS 会以**处理二进制的方式**来处理SDS存放在buf数组里的数据，即用它来保存一系列二进制数据【以字节形式】，

  **保证了二进制安全，可以保存任意格式的二进制数据。**



### 兼容部分C字符串函数

* SDS中的buf数组的数据末尾总为空字符，使得SDS能重用一部分C字符串函数。
* 通过遵循C字符串以空字符结尾的惯例，避免了不必要的代码重复。



## string使用场景  

*  string使用场景一般是存储简单的信息。比如用户信息，登录信息，配置信息等。还有一种用得比较多的是string的incr/decr操作，即自减/自增操作。调用它是原子性的，无论调用多少次，都一一计算成功。例如需要增减库存的操作。
* **尽管string的value可以存储很大，甚至500多MB的容量。但是在性能上来说，我们尽量存储value的值不要过1MB。**

