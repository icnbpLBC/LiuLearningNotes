# 编程思想五初始化与清理



## 用构造器确保初始化

* 调用构造器是编译器的责任
* **其中不接受任何参数的构造器叫做默认构造器**
* 构造器采用与类相同的名称，初始化期间编译器会自动调用构造器
* 创建对象时，会为对象分配存储空间，并调用相应的构造器
* 构造器没有返回值，与返回值为void不同。构造器不会返回任何东西，(new表达式确实返回了对新建对象的引用，但构造器本身并没有任何返回值)



## 方法重载

* 方法即是给某个动作取的名字
* 方法名相同但形式参数不同的方法存在**同一类**中【与返回类型无关】，即方法重载
* **参数列表又叫参数签名，包括参数的类型、参数的个数、参数的顺序，只要有一个不同就叫做参数列表不同**
* **仅通过返回类型是无法区分重载方法的。**



## 区分方法重载

规则很简单：

**每个重载的方法必须有一个独一无二的参数类型列表**

**说明：**

- 参数列表不同包括：个数不同、顺序不同、类型不同。
- 仅仅参数变量名称不同是不可以的。
- 跟成员方法一样，构造方法也可以重载。
- 涉及基本类型的重载时，较小的类型能自动提升为一个较大的类型
- 声明为final的方法不能被重载。
- 声明为static的方法不能被重载，但是能够被在此声明。

**方法的重载的规则：**

- 方法名称必须相同。
- 参数列表必须不同。
- 方法的返回类型可以相同也可以不相同。
- 仅仅返回类型不同不足以称为方法的重载。



## 默认构造器

* 默认构造函数（也称为无参构造函数）是没有形式参数的。如果你创建的类没有构造函数，编译器会自动为您创建一个默认构造函数。
* 如果已经定义了一个构造器，编译器就不会帮你自动构建默认构造器



## this关键字

* **this关键字指向的是当前对象的引用**，只能在方法内部使用

* **this关键字可用于引用当前的类实例变量。如果实例变量和参数之间存在歧义，则此关键字可解决歧义问题。**
* static方法是没有this的方法，因为static方法无需对象实例即可运行（也没有super）



### 在构造器中调用构造器

* 在构造函数中，**this关键字采用如果为this添加了参数列表时，它就具有不同的含义。 它明确调用了与该参数列表匹配的构造函数**。
* 编译器不让我们从除了一个构建器之外的其他任何方法内部调用一个构建器，且一个构造器中只能调用一个构造器【只能初始化一次】



## 成员初始化

* java尽力保证：所有变量在使用前都能得到恰当的初始化。方法的局部变量，java以编译时出错来贯彻这种保证



### 默认初始化

* **只进行成员变量的定义，不进行主动的初始化操作，由编译器为成员变量赋一个默认值。**

* 对于基本类型，有各自不同的默认值如int、char、short等为0，boolean为false，对于对象，默认值为null。默认初始化主要是为了保证初始化过程一定会得到执行，只发生在成员变量身上，对于局部变量，不存在这种机制。



### 指定初始化

* 如果您想给变量一个初始值怎么办？ 一种直接的方法是**只需在您在类中定义变量的位置分配值即可。**【需注意初始化顺序是否恰当】



### 构造器初始化

* 构造函数可用于执行初始化，这为您提供了更大的灵活性您的编程，因为您可以在运行时调用方法并执行操作以确定初始值。 但是，请记住一件事：**无法阻止自动初始化的进行，它将在构造器被调用之前就发生。**



#### 初始化顺序

* 在一个类中，**变量定义的先后顺序决定了初始化的顺序**。在类中定义。即使变量定义分散在整个方法定义之间，但是**仍然会在任何方法使用之前初始化，甚至是构造函数。**



#### 静态数据初始化

* 无论创建多少个对象，静态存储只占用一份存储空间。不能将static关键字应用于局部变量，因此只能应用于域。 如果一个域是静态的基本类型域，且也没有对它进行显式初始化，**那么它就会获得基本类型的标准初值。如果它是一个对象的引用，默认初始化值为null。**

* 初始化对象的顺序是先静态对象【只在Class对象首次加载时进行一次】，而后是非静态对象，详细在P96



### 显示的静态初始化

* Java允许将多个静态初始化动作组织成一个特殊的“静态子句”（有时称为**静态块**）在一个类中。
* 静态块只执行一次：当首次生成这个类的对象时，或者首次访问属于那个类的静态数据成员时。



### 非静态实例初始化

```java
class Mug {
        Mug(int marker) {
        print("Mug(" + marker + ")");
}
void f(int marker) {
        print("f(" + marker + ")");
}
}
public class Mugs {
        Mug mug1;
        Mug mug2;
        {
        mug1 = new Mug(1);
        mug2 = new Mug(2);
        print("mug1 & mug2 initialized");
        }
        Mugs() {
        print("Mugs()");
        }
        Mugs(int i) {
        print("Mugs(int)");
}
        public static void main(String[] args) {
            print("Inside main()");
            new Mugs();
            print("new Mugs() completed");
            new Mugs(1);
            print("new Mugs(1) completed");
}
}

```

* 代码块中的初始化语句在构造器之前执行，这种语法对于支持匿名内部类的初始化是必须的。



## 数组初始化

* new创建数组时，基本数据类型值会自动初始化为空值（数字和字符都是0，布尔值为false，引用类型为null）

* 可以用花括号括起来的列表来初始化对象

  * ```java
    Integer a = {
        new Integer(1),
        new Integer(2),
        3//自动装箱
    };
    Integer b = new Integer[]{
        new Integer(1),
        new Integer(2),
        3
    };
    ```



## 可变参数列表

- 可变参数列表其实是一个数组，作为函数f()的形参时，函数f()既可以接受一个数组，也可以接受可变参数列表，编译器自动将可变参数列表变为数组，也可调用方法时无参数传入对应为长度为0的数组
- 可变参数列表声明如下 void f(int... is);



## 枚举类型

- 枚举类型的实例是常量，因此按照命名习惯，枚举值一般用全大写字母（多个单词用下划线隔开）

- 为了使用 enum，需要创建一个该类型的引用，并将其赋值给某个实例

  - ```java
    Spiciness howHot = Spiciness.MEDIUM;
    ```

- enum 会自动创建一些实用的函数，如`toString()`显示其名称，`ordinal()`表示声明顺序，以及`static values()`方法用来按照声明顺序产生由这些常量值构成的数组。

- enum 适合与 switch 一起使用

