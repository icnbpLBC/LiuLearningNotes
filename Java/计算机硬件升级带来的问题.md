## 内存模型的引入

### 多级缓存和一致性问题

* 随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，**从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。**
* 人们想出来了一个好的办法，就是在CPU和内存之间增加高速缓存。缓存的概念大家都知道，就是保存一份数据拷贝。他的特点是**速度快，内存小，并且昂贵。**
* 程序的执行过程就变成了：**当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。**
* 而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出**多级缓存**。按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L2），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。
* **当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。**
* 单核CPU只含有一套L1，L2，L3缓存；如果CPU含有多个核心，即**多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。**
* 单核CPU，多线程环境不会出现缓存一致性问题。
* **多核CPU，多线程。**才会出现缓存一致性问题。
* 在CPU和主存之间增加缓存，在多线程场景下就可能存在**缓存一致性问题**，也就是说，**在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。**![image-20211226211943932](D:\Typora\typora-user-images\img\img\image-20211226211943932.png)

### CPU时间片与原子性问题

* 我们说原子性问题，其实指的是**多线程场景中操作如果不能保证原子性，会导致处理结果和预期不一致。**
* 线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。所以在多线程场景下，就会发生原子性问题。因为线程在执行一个`读改写`操作时，在执行完`读改`之后，时间片耗完，就会被要求放弃CPU，并等待重新调度。这种情况下，`读改写`就可能不是一个原子操作。
* **在单线程中，一个`读改写`就算不是原子操作也没关系，因为只要这个线程再次被调度，这个操作总是可以执行完的。但是在多线程场景中可能就有问题了。因为多个线程可能会对同一个共享资源进行操作。**

### 指令重排与有序性问题

* 由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如`load`->`add`->`save` 有可能被优化成`load`->`save`->`add` 。这就是有序性问题。



## 计算机内存模型

* 为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——**内存模型**。
* **为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。**通过这些规则来规范对内存的读写操作，从而**保证指令执行的正确性。**它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。
* 内存模型解决并发问题主要采用两种方式：限制处理器优化和使用内存屏障。



### 内存一致性和缓存一致性

* 缓存一致性（Cache Coherence），解决是多个缓存副本之间的数据的一致性问题。
* 内存一致性（Memory Consistency），保证的是多线程程序访问内存时可以读到什么值。

### 缓存一致性和可见性

* 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
* **缓存一致性问题其实就是可见性问题。**
* 但是，如果站在Java并发编程的角度来看的话，可见性问题和缓存一致性问题并不完全一样。
* 在Java中，所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。![img](http://www.hollischuang.com/wp-content/uploads/2018/07/JAVA.png)
* **这里面提到的主内存和工作内存，并不是计算机主存和缓存。可以类比，但不完全是。**
* 所以，**Java中的可见性问题，其实是各个线程的本地内存之间的数据互相不可见。即线程中本地内存的一致性问题。**



## Java内存模型

* 我们知道，Java程序是需要运行在Java虚拟机上面的，**Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。**
* **JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。**
* 总结：**JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。**



## Java内存模型的实现

### Java内存模型的实现原理

* 在Java中提供了一系列和并发处理相关的关键字，比如volatile、synchronized、final、concurren包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。

* Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。
* 并发编程要解决原子性、有序性和一致性的问题，分别使用什么方式来保证的。

### 原子性

* 在Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit。**可以通过这两个指令来保证原子性。**
* synchronized其实底层就是使用monitorenter和monitorexit实现的，所以，**在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。**

### 可见性

* **Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。**
* **Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。**
* 除了volatile，Java中的synchronized和final两个关键字也可以实现可见性。只不过实现方式不同，后续再介绍到这两个关键字的时候会再次展开。

### 有序性

* 在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别：

  **volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。**

### 小结

* 简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。
* **Java中提供了很多关键字和API可以帮助我们保证并发编程中的原子性、可见性以及有序性，不同的关键字和API有着不同的实现**



## synchronized

### 什么是synchronized

* `synchronized` 是 Java 中的一个很重要的关键字，主要用来加锁，`synchronized` 所添加的锁有以下几个特点。
  * 互斥性
  * 阻塞性
  * 可重入性

### synchronized 的用法

* 主要可以用来修饰方法和代码块
* 又可分为对象锁和类锁，对象锁锁定的内容是对象，类锁锁定的内容是类。PS：其实，类锁也是通过对象锁实现的，因为在 Java 中，万物皆对象。

### synchronized 原理总结

* 同步方法通过 `ACC_SYNCHRONIZED` 关键字**隐式的对方法进行加锁**。当线程要执行的方法被标注上 `ACC_SYNCHRONIZED` 时，**需要先获得锁才能执行该方法。**
* 同步代码块通过 `monitorenter` 和 `monitorexit` 执行来进行加锁。当线程执行到 `monitorenter` 的时候要先获得所锁，才能执行后面的方法。当线程执行到 `monitorexit` 的时候则要释放锁。
* 每个对象自身维护这一个被加锁次数的计数器，当计数器数字为 0 时表示可以被任意线程获得锁。当计数器不为 0 时，只有获得锁的线程才能再次获得锁。即可重入锁。
* **无论是同步方法还是同步代码块，其实现其实都要依赖对象的监视器（Monitor）**，那么到底什么是 Monitor，Monitor 又是如何进行加锁和解锁的呢？

#### Monitor 的实现原理

https://www.hollischuang.com/archives/4117

密码hollis和他的朋友们

### Monitor 原理总结

* `synchronized` 对某个对象进行加锁的时候，会调用该对象拥有的 objectMonitor 的 `enter` 方法，解锁的时候会调用 `exit` 方法。
* **事实上，只有在 JDK1.6 之前，`synchronized` 的实现才会直接调用 ObjectMonitor 的 `enter` 和 `exit` ，这种锁被称之为重量级锁。**为什么说这种方式操作锁很重呢？
  * **Java 的线程是映射到操作系统原生线程之上的，如果要阻塞或唤醒一个线程就需要操作系统的帮忙，这就要从用户态转换到核心态，因此状态转换需要花费很多的处理器时间**，对于代码简单的同步块（如被 `Synchronized` 修饰的 `get` 或 `set` 方法）状态转换消耗的时间有可能比用户代码执行的时间还要长，所以说 `synchronized` 是 java 语言中一个重量级的操纵。
* **所以，在 JDK1.6 中出现对锁进行了很多的优化，进而出现轻量级锁，偏向锁，锁消除，适应性自旋锁，锁粗化(自旋锁在 1.4 就有 只不过默认的是关闭的，JDK1.6 是默认开启的)，这些操作都是为了在线程之间更高效的共享数据 ，解决竞争问题。**



## 如何保证线程安全

* 并发编程最大的挑战解决如何解决多个线程之前的原子性、有序性以及可见性。而synchronized作为Java并发模型中必不可少的一个关键字，那么他是如何解决这三个问题的呢？

### synchronized与原子性

* 原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。
* synchonized其实是通过 monitorenter 和 monitorexit 这两个字节码指令实现原子性的。
* 当线程执行到 monitorenter 的时候要先获得锁，才能执行后面的方法。当线程执行到 monitorexit 的时候则要释放锁。
* **在未释放之前，其他线程是无法再次获得锁的，所以，通过monitorenter和monitorexit指令，可以保证被synchronized修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到。因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。**
* 即使在执行过程中，由于某种原因，比如**CPU时间片用完，线程1放弃了CPU，但是，他并没有进行解锁。而由于synchronized的锁是可重入的，下一个时间片还是只能被他自己获取到，还是会继续执行代码。直到所有代码执行完。这就保证了原子性。**



### synchronized与有序性

* 有序性即程序执行的顺序按照代码的先后顺序执行。
* **as-if-serial语义的意思指：不管怎么重排序，单线程程序的执行结果都不能被改变。编译器和处理器无论如何优化，都必须遵守as-if-serial语义。**
* **所以呢，由于synchronized修饰的代码，同一时间只能被同一线程访问。那么也就是单线程执行的。所以，可以保证其有序性。**



### synchronized与可见性

* 可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
* java内存模型的一条happen-before原则：对一个变量解锁之前，必须先把此变量同步回主存中。这样解锁后，后续线程就可以访问到被修改后的值。
* 所以，synchronized关键字锁住的对象，其值是具有可见性的。



## 锁优化

* 只有在 JDK1.6 之前，synchronized 的实现才会直接调用 ObjectMonitor 的 enter 和 exit ，这种锁被称之为重量级锁。那么什么是重量级锁？JDK 1.6之后发生了什么？
* 高效并发是从JDK 1.5 到 JDK 1.6的一个重要改进，HotSpot虚拟机开发团队在这个版本中花费了很大的精力去对**Java中的锁进行优化，如适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等。这些技术都是为了在线程之间更高效的共享数据，以及解决竞争问题。**

### 自旋锁

* 如果物理机上有多个处理器，可以让多个线程同时执行的话。我们就可以**让后面来的线程“稍微等一下”，但是并不放弃处理器的执行时间，看看持有锁的线程会不会很快释放锁。这个“稍微等一下”的过程就是自旋。**
* 自旋锁在JDK 1.4中已经引入，在JDK 1.6中默认开启。
* **自旋锁和阻塞锁最大的区别就是，到底要不要放弃处理器的执行时间。对于阻塞锁和自旋锁来说，都是要等待获得共享资源。但是阻塞锁是放弃了CPU时间，进入了等待区，等待被唤醒。而自旋锁是一直“自旋”在那里，时刻的检查共享资源是否可以被访问。**
* 由于**自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。如果线程竞争不激烈，并且保持锁的时间短。适合使用自旋锁。**

### 锁消除

* **在动态编译同步块的时候，JIT编译器可以借助一种被称为逃逸分析（Escape Analysis）的技术来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。**
* **如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。**
* **在使用`synchronized`的时候，如果JIT经过逃逸分析之后发现并无线程安全问题的话，就会做锁消除。**

### 锁粗化

* 如果在一段代码中连续的对同一个对象反复加锁解锁，其实是相对耗费资源的，这种情况可以适当**放宽加锁的范围，减少性能消耗。**
* **当JIT发现一系列连续的操作都对同一个对象反复加锁和解锁，甚至加锁操作出现在循环体中的时候，会将加锁同步的范围扩散（粗化）到整个操作序列的外部。**

### 总结

* 自Java 6/Java 7开始，Java虚拟机对内部锁的实现进行了一些优化。这些优化主要包括锁消除（Lock Elision）、锁粗化（Lock Coarsening）、偏向锁（Biased Locking）以及适应性自旋锁（Adaptive Locking）。**这些优化仅在Java虚拟机server模式下起作用（即运行Java程序时我们可能需要在命令行中指定Java虚拟机参数“-server”以开启这些优化）。**
* **本文主要介绍了自旋锁、锁粗化和锁消除的概念。在JIT编译过程中，虚拟机会根据情况使用这三种技术对锁进行优化，目的是减少锁的竞争，提升性能。**



## 实现单例

* 想要把单例模式写好，也没那么容易的，最重要的一个问题就是如何解决**并发场景下的单例生成。**

### 懒汉单例

* 单例模式重要的实现方式就是把构造函数设置成private

* 线程不安全的懒汉单例：

  ```java
  public class Singleton {  
      private static Singleton instance;  
      private Singleton (){}  
      public static Singleton getInstance() {  
      if (instance == null) {  
          instance = new Singleton();  
      }  
      return instance;  
      }  
  }  
  ```

* 线程安全的懒汉单例：

  ```java
  public class Singleton {  
      private static Singleton instance;  
      private Singleton (){}  
      public static synchronized Singleton getInstance() {  
      if (instance == null) {  
          instance = new Singleton();  
      }  
      return instance;  
      }  
  }  
  ```

### 双重校验锁

* 使用同步代码块，减少锁的粒度。

* 无法保证可见性即线程不安全的双重校验模式：

  ```java
  public class Singleton {  
      private static Singleton singleton;  
      private Singleton (){}  
      public static Singleton getSingleton() {  
      if (singleton == null) {  
          synchronized (Singleton.class) {  
          if (singleton == null) {  
              singleton = new Singleton();  
          }  
          }  
      }  
      return singleton;  
      }  
  }  
  ```

* 保证可见性即线程安全的双重校验模式：

  ```java
  public class Singleton {  
      // volatile: 保证可见性
      private volatile static Singleton singleton;  
      private Singleton (){}  
      public static Singleton getSingleton() {  
      if (singleton == null) {  
          synchronized (Singleton.class) {  
          if (singleton == null) {  
              singleton = new Singleton();  
          }  
          }  
      }  
      return singleton;  
      }  
  }  
  ```

  
